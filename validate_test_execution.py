#!/usr/bin/env python3
"""
Validate that MPI tests were executed on all expected ranks.

This script parses the JUnit XML report generated by cargo-nextest and verifies
that each test case has the expected log entries in system-err, confirming that
all MPI ranks executed the test body.
"""

import sys
import re
import xml.etree.ElementTree as ET
from pathlib import Path


def extract_num_processes(test_name: str) -> int | None:
    """
    Extract the number of MPI processes from the test name.

    Test names follow the pattern: test_name::mpi_np_N
    where N is the number of processes.

    Args:
        test_name: The name of the test case

    Returns:
        Number of processes, or None if not found
    """
    match = re.search(r'::mpi_np_(\d+)$', test_name)
    if match:
        return int(match.group(1))
    return None


def validate_test_execution(testcase: ET.Element) -> tuple[bool, str]:
    """
    Validate that a test case was executed on all expected MPI ranks.

    Args:
        testcase: The XML element representing a test case

    Returns:
        Tuple of (success, message)
    """
    test_name = testcase.get('name', 'unknown')
    num_processes = extract_num_processes(test_name)

    if num_processes is None:
        return False, f"Could not extract number of processes from test name: {test_name}"

    # Find the system-err element
    system_err = testcase.find('system-err')
    if system_err is None:
        return False, f"Test {test_name}: No system-err element found"

    stderr_text = system_err.text or ""

    # Look for log entries: RANK_N_reached_test_body
    # Note: The output can get scrambled when multiple processes write simultaneously
    found_ranks = set()

    # Standard pattern: RANK_N_reached_test_body
    for match in re.finditer(r'RANK_(\d+)_reached_test_body', stderr_text):
        rank = int(match.group(1))
        found_ranks.add(rank)

    # Scrambled patterns where multiple ranks write at the same time
    # e.g., "RANK_RANK_2_reached_test_body" or "RANK_0RANK_1_reached_test_body"
    for match in re.finditer(r'RANK[_\d]*?(\d+)[_\w]*?reached_test_body', stderr_text):
        rank = int(match.group(1))
        found_ranks.add(rank)

    # Handle cases where rank number appears before "RANK_" (e.g., "0RANK_1_...")
    # or standalone numbers followed by "_reached_test_body" or similar patterns
    for match in re.finditer(r'\b(\d+)(?:RANK_|_reached_test_body)', stderr_text):
        rank = int(match.group(1))
        # Only consider reasonable rank numbers (0-999)
        if 0 <= rank < 1000:
            found_ranks.add(rank)

    # Check that we found logs for all expected ranks (0 to num_processes-1)
    expected_ranks = set(range(num_processes))

    if found_ranks != expected_ranks:
        missing_ranks = expected_ranks - found_ranks
        extra_ranks = found_ranks - expected_ranks

        error_parts = [f"Test {test_name}: Expected {num_processes} ranks"]
        if missing_ranks:
            error_parts.append(f"Missing logs from ranks: {sorted(missing_ranks)}")
        if extra_ranks:
            error_parts.append(f"Unexpected logs from ranks: {sorted(extra_ranks)}")

        return False, ". ".join(error_parts)

    return True, f"Test {test_name}: OK"


def main():
    """Main entry point."""
    if len(sys.argv) < 2:
        print("Usage: validate_test_execution.py <junit_xml_path>", file=sys.stderr)
        sys.exit(1)

    junit_path = Path(sys.argv[1])

    if not junit_path.exists():
        print(f"Error: File not found: {junit_path}", file=sys.stderr)
        sys.exit(1)

    try:
        tree = ET.parse(junit_path)
        root = tree.getroot()
    except ET.ParseError as e:
        print(f"Error parsing XML: {e}", file=sys.stderr)
        sys.exit(1)

    # Find all test cases
    testcases = root.findall('.//testcase')

    if not testcases:
        print("Warning: No test cases found in JUnit report", file=sys.stderr)
        sys.exit(1)

    print(f"Validating {len(testcases)} test cases...\n")

    success_count = 0
    failure_count = 0
    failures = []

    for testcase in testcases:
        success, message = validate_test_execution(testcase)

        if success:
            print(f"[PASS] {message}")
            success_count += 1
        else:
            print(f"[FAIL] {message}")
            failures.append(message)
            failure_count += 1

    print(f"\n{'=' * 80}")
    print(f"Results: {success_count} passed, {failure_count} failed")
    print(f"{'=' * 80}")

    if failures:
        print("\nFailures:")
        for failure in failures:
            print(f"  - {failure}")
        sys.exit(1)
    else:
        print("\n[SUCCESS] All tests executed on expected number of MPI ranks!")
        sys.exit(0)


if __name__ == '__main__':
    main()
